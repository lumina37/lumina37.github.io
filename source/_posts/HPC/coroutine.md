---
title: C++第三方协程库源码阅读
categories: HPC
date: 2025/7/21 13:29:00
mathjax: true
---

## 前言

最近要重写一个Windows MediaFoundation的封装，其中涉及到一些异步场景，计划用C++20 Coroutine实现异步逻辑，因此我就写下这篇文章作为学习总结，顺便帮一些想学习C++协程的朋友少走弯路。另外也是觉得最近休息时间什么都不想做，秋招的高压之下确实需要一个锚点用来保持学习状态。

## 什么是协程

如果说**线程**是由操作系统在内核态管理的状态机，那么**协程**就是完全由开发者在用户态管理的状态机。这样的设计有以下好处：

1. **提高了开发者对任务调度、资源调度等调度模型的掌控能力**。更具体的，在任务调度模型方面，协程的挂起与恢复时机都可以由开发者完全控制，协程可以选用协作式的调度模型，主动出让CPU给事件循环或其他协程；在资源调度模型方面，协程可以使用更自适应的上下文大小，实现单机上百万的协程并发。
2. **减少操作系统调用的开销**。这其中不仅包括线程切换所需的系统调用，还包括同步原语所需的一些系统调用。

## 协程的历史

协程（Coroutine）一词，最早于1963年由Melvin Conway在他的操作系统著作中提出。

当时间来到1980年代，多线程设计兴起。在多线程设计中，用于保存线程状态的结构体（`task_struct`）与调度器由操作系统内部实现。操作系统对外提供标准化接口，开发者无须关注内部细节，就可以较为轻松的扩大并行规模。对比之下，协程的状态结构和调度器均需要编程语言或开发者自行实现。由于当时的系统调用与线程调度所消耗的性能相较缓慢的业务程序而言实在不值一提，协程相较多线程几乎没有优势。

直到千禧年后，随着计算机的提速与光纤技术在互联网通信中的铺开应用，在高性能网络程序中，系统调用与线程调度的耗时占比越来越多，开发者对框架灵活性的需求也越来越大。在2012年，微软向C#语言的核心特性中添加了async/await关键字，这标志着协程首次进入主流编程语言的视野。随后，2015年的Python3.5和JavaScript ES6分别添加了async/await和future/promise来支持协程开发。在10年后诞生的年轻语言，大多出厂便自带协程语法糖（如Rust/Kotlin）或是运行时设施（如Go）。2017年，承载着标准协程库使命的Coroutine TS被提交到C++标准委员会，并于2020年的C++20中正式发布为标准协程库<coroutine>。

在最近的20年间，业界主流的设计范式更是从操作系统大包大揽的重内核设计，逐渐向高自由度+低overhead的旁路内核设计转移。这种设计有如一把双刃剑，将更丰富的底层细节暴露给上游开发者，允许上游开发者执行更深入的优化，也相应地使得框架的学习曲线更陡峭，提高了工程的开发和维护成本。

## 协程的分类

C++中的标准协程库采用了**无栈非对称**设计。

### 有栈与无栈

我们先对无栈协程与有栈协程做一下区分。有栈协程的工作方式与线程非常相似。众所周知，每个线程都有一个调用栈。函数调用时，操作系统会将返回地址与参数压入调用栈；函数返回时，再从栈上弹出返回地址，并跳转到对应地址处继续执行。有栈协程也有调用栈，这也是“有栈”名字的由来。只不过有栈协程的调用栈由协程库在用户态申请，而线程的调用栈由操作系统在内核态申请。顾名思义，“无栈”的意思就是无栈协程没有这个模拟出来的调用栈了。

上面讲了无栈协程与有栈协程在设计上的不同点。这种设计差异又会带来什么功能上的差异呢？有栈协程拥有的那个调用栈所带来的优势包括：

1. 有栈协程可以在任意位置挂起，再转去执行抢占式调度器或是另一个有栈协程。换一种更精准的表述就是，有栈协程可以在任意时间将其**在CPU核上执行的权利**交还给抢占式调度器，或是转交给另一个有栈协程。这种切换和线程的切换方式非常类似，保存一下调用栈指针和寄存器等上下文信息就可以执行切换。在腾讯2013年开源的有栈协程库[libco](https://github.com/Tencent/libco)中就使用了这么一段[汇编代码](https://github.com/Tencent/libco/blob/master/coctx_swap.S)来实现上下文状态的保存与协程切换。而无栈协程只能在一个特定的标记点（一般由`await`或`yield`标记）挂起，并将执行权交还给主调度器。
2. 将业务代码迁移到有栈协程几乎不需要任何改动。而无栈协程往往需要添加非常多的`async`/`await`标记点，用于辅助编译器或解释器生成状态机，这就是俗称的`async`/`await`污染。

而有栈协程的劣势有以下几点：

1. 有栈协程的完整实现需要将操作系统中耗时较长的同步函数封装成异步的形式。
2. 在调试调用栈时，有栈协程需要自行设计栈回溯机制，而那些依托标准库设施的无栈协程一般会有较好的调试器支持。
3. 有栈协程的调用栈大小难以预估，当函数嵌套调用过多时容易导致栈溢出，动态扩容的机制实现起来又比较复杂。
4. 有栈协程的切换过程需要保存大量上下文状态，切换耗时约为几十纳秒，而无栈协程的切换仅需几纳秒。

为何包括C++/C#/Python/Rust/R/Kotlin/Swift在内的大部分编程语言的标准协程库都是无栈协程？而大公司在生产环境应用的协程库，包括谷歌的goroutine、腾讯的tRPC在内，又有相当一部分是有栈协程？

大部分编程语言都希望尽可能避免引入额外的运行时开销，而在有栈协程中，系统函数的异步封装方式、栈扩容方法、上下文保存方法都难以被标准化，因此这些编程语言才纷纷选择无栈协程的路线。而在实际工程中，企业最优先关注的是对原有业务的兼容性，其次是稳健性，然后是扩展性与可维护性，最后才是非必要不考虑的性能优化。因此，可以与旧业务代码流畅兼容的有栈协程自然更受青睐。

### 非对称与对称

非对称协程，意味着在每个挂起点，协程都要将**在CPU核上执行的权利**交还给主协程。协程一般需要实现一个`suspend`方法用于挂起，以及一个`resume`方法用于恢复执行。而对称协程可以将在CPU核上执行的权利交给另一个协程。协程之间的“地位”是对称的。此时协程一般需要实现一个`yield_to`或者`resume_on`方法用来指定接下来要运行的协程。

在有栈协程上实现对称协程较为安全。而在无栈协程上实现对称协程无异于允许goto乱飞，非常容易出bug。因此绝大多数无栈协程都是非对称协程。

通常，非对称协程中的主协程是一个事件循环（EventLoop）。事件循环会轮流恢复（resume）唤醒队列中的协程，以推动它们进一步执行。在此过程中，若协程执行完毕，事件循环会将其移除；若协程再次挂起，事件循环会将其从唤醒队列移入等待队列。当唤醒队列为空时，事件循环会在一个等待IO、计时器或信号事件的操作系统调用（如`epoll_wait`）上阻塞。当这个等待新事件的操作系统调用返回时，事件循环会将这些事件对应的所有协程从等待队列移入唤醒队列，并轮流恢复它们的执行。
