---
title: C++协程库源码阅读
categories: HPC
date: 2025/7/21 13:29:00
mathjax: true
---

## 前言

最近要重写一个Windows MediaFoundation的封装，其中涉及到一些异步场景，团队内部研究了一下决定用C++20 Coroutine实现异步逻辑，因此我就写下这篇文章作为学习总结，顺便帮一些想学习C++协程的朋友少走弯路。另外也是觉得最近休息时间什么都不想做，秋招的高压之下确实需要一个锚点用来保持学习状态。

## 协程的历史

协程（Coroutine）一词，最早于1963年由Melvin Conway在他的操作系统著作中提出。

当时间来到1980年代，多线程设计兴起。在多线程设计中，用于保存线程状态的结构体（`task_struct`）与调度器由操作系统内部实现。操作系统对外提供标准化接口，开发者无须关注内部细节，就可以较为轻松的扩大并行规模。对比之下，协程的状态结构和调度器均需要编程语言或开发者自行实现。由于当时的系统调用与线程调度所消耗的性能相较缓慢的业务程序而言实在不值一提，协程相较多线程几乎没有优势。

直到千禧年后，随着计算机的提速与光纤技术在互联网通信中的铺开应用，在高性能网络程序中，系统调用与线程调度的耗时占比越来越多，开发者对框架灵活性的需求也越来越大。在2012年，微软向C#语言的核心特性中添加了async/await关键字，这标志着协程首次进入主流编程语言的视野。随后，2015年的Python3.5和JavaScript ES6分别添加了async/await和future/promise来支持协程开发。在10年后诞生的年轻语言，大多出厂便自带协程语法糖（如Rust/Kotlin）或是运行时设施（如Go）。2017年，承载着标准协程库使命的Coroutine TS被提交到C++标准委员会，并于2020年的C++20中正式发布为标准协程库<coroutine>。

在最近的20年间，业界主流的设计范式更是从操作系统大包大揽的重内核设计，逐渐向高自由度+低overhead的旁路内核设计转移。这种设计有如一把双刃剑，将更丰富的底层细节暴露给上游开发者，允许上游开发者执行更深入的优化，也相应地使得框架的学习曲线更陡峭，提高了工程的开发和维护成本。

## 什么是协程

如果说**线程**是工作在操作系统内核的状态机，那么**协程**就是完全工作在用户空间的状态机。协程的挂起、恢复与取消都可以由开发者完全控制。这样的设计有以下好处：

1. 提高了开发者对任务调度、资源调度等调度模型的掌控能力。更具体的，在任务调度模型方面，协程可以选用协作式的调度模型，主动出让CPU给事件循环或其他协程；在资源调度模型方面，协程可以使用更自适应的上下文大小，实现单机上百万的协程并发。
2. 减少操作系统调用的开销，不仅包括线程切换所需的系统调用，还包括同步原语所需的一些系统调用。
